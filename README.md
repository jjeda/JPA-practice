## 들어가며
- [김영한님의 JPA 강의](https://www.inflearn.com/course/ORM-JPA-Basic#)를 끝내보자
- 기간 : 8.14 ~ 8.22

## 계획
- 8.14 영속성 관리
- 8.15 엔티티 매핑
- 8.17 연관관계 매핑 기초
- 8.18 다양한 연관관계 매핑 & 고급 매핑

- 8.19 프록시와 연관관계 관리
- 8.20 값 타입
- 8.21 객체지향 쿼리 언어1
- 8.22 객체지향 쿼리 언어2

## JPA 기본
- JPA는 엔티티 매니저 팩토리라는 것을 만들어야 한다 // DB당 한개씩 묶임
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 앤티티 매니저를 통해서 작업을 해야 한다
- 엔티티 매니저는 쓰레드간 절대 공유하면 안돼// 사용하고 버릴것
- 모든 데이터 변경은 트랜잭션 안에서 실행해야한다

## JPA에서 가장 중요한 2가지
- 객체와 관계형 데이베이스 매핑하기
- 영속성 컨텍스트 // 실제 내부에서 어떻게 동작?

## 1.영속성 컨텍스트 // JPA를 이해하는데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
- DB에 저장하는 것이아니라 영속성 컨텍스트 라는곳(논리적인 개념)에 저장
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
- 디비와 애플리케이션 사이에 중간 계층을 둠으로써 버퍼링, 캐싱 등의 이점을 가

### 이점 1 : 1차 캐시
- DB에서 값을 가져오기전에 1차 캐시(영속성 컨텍스트)에 있는 것을 가져옴
- 만약 1차 캐시에없다면 DB에서 가져오면서 1차캐시에 저장하고 반환
- 영속엔티티의 동일성(==)도 보장! //같은 트랜잭션안에서

### 이점 2 : 트랜잭션을 지원하는 쓰기 지연 // 쓰기 지연 SQL 저장소
- em.persist(memberA)을 하면 DB가아니라 쓰기 지연 SQL 저장소에 저장
- commit()을 하는 순간 쓰기 지연 SQL 저장소에 저장돼있는 쿼리들이 날아감!
- jdbc.batch option 으로 한번의 network로 여러 쿼리를 보낼 수 있다!

### 이점 3 : 엔티티 수정(Dirty checking) // 변경 감지
- 변경을 하고 persist를 호출해야 하는거아냐? 노노
- 자바 컬렉션 다루듯이 하자
- 이게 어떻게 가능하지?
  - (커밋할 떄) flush()가 호출되면서 1차 캐시 내에 엔티티와 스냅샷(최초 상태) 비교
  - update 쿼리를 쓰기 지연 SQL 저장소에 넣고
  - 마지막에 최종적으로 쿼리를 날림~
  
### 1-1. 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 //커밋할때
- 1차 캐싱을 비우지 않는다 // 플러시 라는 이름에 헷갈리지 말
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 
- 더티체킹, 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 등록
- 영속성 컨텍스트를 플러시하는 방법
  - em.flush() : 직접 호출
  - 트랜잭션 커밋 : 플러시 자동 호출
  - JPQL 쿼리 실행 : 플러시 자동 호출 
    - persist 후 커밋하지않고 중간에 JPQL 실행하게되면 문제가 생김
    - JPA는 이런 문제를 해결하고자 JPQL 실행할 때 플러시를 자동 호출
    - 옵션을 설정해서 자동호출 안할 수 있음~
    
 ### 1-2. 준영속 상태
 - 영속 상태의 엔티티가 영속성 컨텍스트(JPA가 관리하는 상태)에서 분리(detached)
 - 영속성 컨텍스트에서 분리됐기 때문에 제공하는 기능을 사용하지못해
 - 방법
   - em.detach(); // 특정 엔티티만
   - em.clear(); // 1차 캐시에 있는 엔티티 모두
   - em.close(); // 영속성 컨텍스트를 종료