## 들어가며
- [김영한님의 JPA 강의](https://www.inflearn.com/course/ORM-JPA-Basic#)를 끝내보자
- 기간 : 8.14 ~ 8.22

## 계획
- 8.14 영속성 관리
- 8.15 엔티티 매핑
- 8.17 연관관계 매핑 기초
- 8.18 다양한 연관관계 매핑 & 고급 매핑

- 8.19 프록시와 연관관계 관리
- 8.20 값 타입
- 8.21 객체지향 쿼리 언어1
- 8.22 객체지향 쿼리 언어2

## JPA 기본
- JPA는 엔티티 매니저 팩토리라는 것을 만들어야 한다 // DB당 한개씩 묶임
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 앤티티 매니저를 통해서 작업을 해야 한다
- 엔티티 매니저는 쓰레드간 절대 공유하면 안돼// 사용하고 버릴것
- 모든 데이터 변경은 트랜잭션 안에서 실행해야한다

## JPA에서 가장 중요한 2가지
- 객체와 관계형 데이베이스 매핑하기
- 영속성 컨텍스트 // 실제 내부에서 어떻게 동작?

## 1. 영속성 컨텍스트 // JPA를 이해하는데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
- DB에 저장하는 것이아니라 영속성 컨텍스트 라는곳(논리적인 개념)에 저장
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
- 디비와 애플리케이션 사이에 중간 계층을 둠으로써 버퍼링, 캐싱 등의 이점을 가짐
- 성능보다는 매커니즘에서 얻을 수 있는 이점

#### 이점 1 : 1차 캐시
- DB에서 값을 가져오기전에 1차 캐시(영속성 컨텍스트)에 있는 것을 가져옴
- 만약 1차 캐시에없다면 DB에서 가져오면서 1차캐시에 저장하고 반환
- 영속엔티티의 동일성(identity)도 보장! //같은 트랜잭션안에서

#### 이점 2 : 트랜잭션을 지원하는 쓰기 지연 // 쓰기 지연 SQL 저장소
- em.persist(memberA)을 하면 DB가아니라 쓰기 지연 SQL 저장소에 저장
- commit()을 하는 순간 쓰기 지연 SQL 저장소에 저장돼있는 쿼리들이 날아감!
- jdbc.batch option 으로 한번의 network로 여러 쿼리를 보낼 수 있다!

#### 이점 3 : 엔티티 수정(Dirty checking) // 변경 감지
- 변경을 하고 persist를 호출해야 하는거아냐? 노노
- 자바 컬렉션 다루듯이 하자
- 이게 어떻게 가능하지?
  - (커밋할 떄) flush()가 호출되면서 1차 캐시 내에 엔티티와 스냅샷(최초 상태) 비교
  - update 쿼리를 쓰기 지연 SQL 저장소에 넣고
  - 마지막에 최종적으로 쿼리를 날림~
  
#### 이점 4 : 지연로딩(Lazy Loading)
  
#### 1-1. 플러시
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 //커밋할때
- 1차 캐싱을 비우지 않는다 // 플러시 라는 이름에 헷갈리지 말
- **트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면**
- 더티체킹, 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 등록
- 영속성 컨텍스트를 플러시하는 방법
  - em.flush() : 직접 호출
  - 트랜잭션 커밋 : 플러시 자동 호출
  - JPQL 쿼리 실행 : 플러시 자동 호출 
    - persist 후 커밋하지않고 중간에 JPQL 실행하게되면 문제가 생김
    - JPA는 이런 문제를 해결하고자 JPQL 실행할 때 플러시를 자동 호출
    - 옵션을 설정해서 자동호출 안할 수 있음~
    
 #### 1-2. 준영속 상태
 - 영속 상태의 엔티티가 영속성 컨텍스트(JPA가 관리하는 상태)에서 분리(detached)
 - 영속성 컨텍스트에서 분리됐기 때문에 제공하는 기능을 사용하지못해
 - 방법
   - em.detach(); // 특정 엔티티만
   - em.clear(); // 1차 캐시에 있는 엔티티 모두
   - em.close(); // 영속성 컨텍스를 종료
   
## 2. 엔티티 매핑
- 객체와 테이블 매핑 // @Entity, @Table
- 데이터베이스 스키마 자동 생성
- 필드와 컬럼 매핑 //Column
- 기본 키 매핑
- Enumerated(EnumType.ORIDNAL) 을 쓰면 안되는이유?
  - INTEGER 타입으로 순서가 들어가기 때문에
  - ENUM 타입이 추가되면 알 수가없다..

#### 2-1. 기본 키 매핑
- @GeneratedValue(strategy = GenerationType.X)
  - IDENTITY : 기본 키 생성을 데이터베이스에 위임 // auto_increment
  - SEQUENCE : 유일한 값을 순서대로 생성하는 데이터베이스 오브젝트
  - TABLE : 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내냄
- 권장하는 식별자 전략
  - 기본 키 제약 조건 : Not Null, unique, **변하면 안된다**
  - 미래까지 이 조건을 만족하는 자연키(email, 전화번호) 찾기 어렵다-> 대리키 사용
  - 주민등록번호도 적절하지 않음
  - LONG형 + 대체키 + 키 생성전략 사용
  
#### 2-2. IDENTITY 전략 - 특징
- 상황 : 내가 값을 넣지 않는다 (Null 이면 자동으로 값을 setting 해줌)
- 뭐가 문제? DB에 가봐야 ID값을 알 수 있다.
- 그런데 영속성 컨텍스트에서 관리 되려면 무조건 PK값이 있어야 함
- em.persist() 를 호출하자마자 바로 DB에 Insert 쿼리를 날림 // commit 시점이아니라
- 즉 모아서 INSERT 하는 것이 IDENTITY에서는 불가능 함

#### 2-3. SEQUENCE 전략 - 특징
- 마찬가지로 PK를 먼저 가져와야 해
- DB에 다음값을 받아와서 영속성 컨텍스트에 저장
- PK값만 받아오기 때문에 INSERT 쿼리는 안날아가~ // commit 시점에 INSERT
- 버퍼링 가능
- 성능상으로 그냥 INSERT 하면 되지않을까..?
  - allocationSize를 통해 미리 50개 size를 DB에 올려놓고 쓰면
  - next call을 매번 안해도 돼
  - **동시성 이슈없이 다양한 문제 해결 가능**
  - DB SEQ = 1 이네? 한번 더 호출 해서 DB SEQ = 51 미리 확보
  - DB SEQ = 1 | 1 //실제 사용 메모리
  - DB SEQ = 51 | 2
  - DB SEQ = 51 | 3 ... 
  - DB SEQ = 51 | 51 -> DB SEQ = 101
  
## 3. 연관관계 매핑 기초
- 객체의 참조와 테이블의 외래 키를 매핑
- '객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.' - 조영호
- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾고
- 객체는 참조를 사용해서 연관된 객체를 찾는다
- 패러다임의 불일치..

#### 3-1. 양방향 연관관계와 연관관계의 주인
- 객체(참조) 테이블(외래키 조인) 차이를 이해 해야해 그래야 연관관계의 주인을 이해할 수 있지 ㅎㅎ
- 객체는 가급적 단방향이 좋지만.. 서로 참조가 가능하지^^
- JPA의 멘붕 난이도 /* mappedBy */
  - 사실 객체의 연관관계에서 양방향 연관관계는 단방향이 두개 있는거야
  - 반대로 테이블은 연관관계 자체가 양방향 관계 1개이지 (foreign key 하나로 양쪽 다 알수있어)
  - 이 패러다임의 불일치
- 연관관계의 주인(Owner)
  - 아니 그러면 객체의 양방향 연관관계에서 누가 관계의 주인이야? // 둘이 다른 행위를 하면 어떡해?
  - 하나를 연관관계의 주인으로 지정하자
  - 주인만이 외래 키를 관리(등록, 수정)
  - 주인이 아닌쪽은 읽기만 가능
  - 주인은 mappedBy 속성 사용 X
  - 주인이 아니면 mappedBy 속성으로 주인 지정
  - 누구를 주인으로? 외래키가 있는 곳을 주인으로 정해라~  // DB 입장에서 외래키가 있는곳이 Many (N쪽이 무조건 주인)
  - 그래야 멤버를 바꾸면 멤버에 대한 업데이트 쿼리가 나가지~ // 팀에서 바꿨는데 멤버에 업데이트 쿼리나가면..? 
  - 그런데 객체지향 관점에서는 양쪽다 넣어주는 것이 맞음..
    - flush, clear 가 있으면 상관없는데 // 1차 캐시에만 있는 상태에서는 가져오지 못해~
    - 테스트케이스에서는 JPA 없이도 동작해야하기 때문
    - 헷갈릴 수 있기 때문에 연관관계 편의 메소드를 생성하자
    - 매핑시 무한 루프를 조심하자 // toString(), lombok, JSON 생성 라이브러리
    - JSON 생성 라이브러리 : 컨트롤러에서 절대로 엔티티를 반환하지 말라 // DTO를 만들자
